# Design of `cfg-iif`

## 1. Overview

The `cfg-iif` crate provides a single, powerful declarative macro, `cfg_iif!`. The design is centered around simplicity and alignment with standard Rust idioms for conditional compilation, while offering a more flexible, function-like interface than existing solutions like `cfg_if`.

## 2. Core Component: `cfg_iif!` Macro

The entire public API consists of the `cfg_iif!` macro. This macro is implemented using `macro_rules!` to ensure it works on stable Rust and in `no_std` environments.

### 2.1. Macro Arms (Implementation Strategy)

The macro is structured with four distinct arms to handle the different syntax variations required:

1.  **Standard `if-else`:**
    -   **Matcher:** `(#[cfg($($cfg_meta:meta),*)] { $($true_it:tt)* } else { $($false_it:tt)* })`
    -   **Expansion:** This arm captures a standard `#[cfg(...)]` attribute, a "true" token tree, and a "false" token tree. It expands to two blocks:
        -   A `#[cfg(...)]` block containing the `true_it` tokens.
        -   A `#[cfg(not(...))]` block containing the `false_it` tokens.
    -   This directly implements **AC5**.

2.  **Standard `if` (no `else`):**
    -   **Matcher:** `(#[cfg($($cfg_meta:meta),*)] { $($it:tt)* })`
    -   **Expansion:** This arm captures the `#[cfg(...)]` attribute and a single token tree. It expands to a single `#[cfg(...)]` block containing the `it` tokens.
    -   This directly implements **AC6**.

3.  **Shorthand `if-else`:**
    -   **Matcher:** `($($cfg_meta:meta),* { $($true_it:tt)* } else { $($false_it:tt)* })`
    -   **Expansion:** This is a syntactic sugar variant. It captures the configuration metadata directly, followed by the true/false token trees. It expands to the exact same code as the standard `if-else` arm, effectively reusing the same core logic.
    -   This directly implements **AC7**.

4.  **Shorthand `if` (no `else`):**
    -   **Matcher:** `($($cfg_meta:meta),* { $($it:tt)* })`
    -   **Expansion:** Similar to the shorthand `if-else`, this is a sugar for the standard `if`. It expands to the same code as the standard `if` arm.
    -   This directly implements **AC8**.

### 2.2. Expression and Statement Support

All macro arms are wrapped in an extra set of curly braces `{{ ... }}`. This is a crucial design choice that allows the macro to be used as an expression. The block will evaluate to the value of the last expression within it, naturally supporting **AC9**. When used as a statement (e.g., ending with a semicolon), the value is simply discarded, fulfilling **AC10**.

## 3. `no_std` Compatibility

The crate is designed to be `no_std` compatible (**AC2**). This is achieved by:
-   Adding the `#![no_std]` attribute at the crate root.
-   Using only `macro_rules!`, which has no dependency on the standard library.

## 4. Testing Strategy

The design includes a `#[cfg(test)]` module to house unit tests, fulfilling **AC11**. The tests are designed to:
-   Be self-contained within the `lib.rs` file.
-   Use `assert_eq!` to compare the output of the `cfg_iif!` macro against a standard, verbose `#[cfg]` block, ensuring correctness.
-   Cover both the standard and shorthand forms of the macro.
-   Test both expression-based (assignment to a variable) and statement-based (mutable variable modification) usages.
-   Use a feature flag (`has_abc`) and a target family (`unix`/`windows`) to test different kinds of `cfg` attributes.
